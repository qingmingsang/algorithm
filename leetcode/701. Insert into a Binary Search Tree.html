<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>hello</title>
  <meta name="description" content="">
  <meta name="valwords" content="">
  <!-- <link rel="shortcut icon" href="favicon.ico"> -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- 默认使用webkit内核 -->
  <meta name="renderer" content="webkit">
  <!-- 兼容模式 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <link href="" rel="stylesheet">
</head>

<body>
  <!-- 

    701. Insert into a Binary Search Tree
Medium

482

54

Favorite

Share
Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.

Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.

For example, 

Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
You can return this binary search tree:

         4
       /   \
      2     7
     / \   /
    1   3 5
This tree is also valid:

         5
       /   \
      2     7
     / \   
    1   3
         \
          4

 -->
  <script>
    console.time();
    // // 二叉树构造函数
    function BinaryTree() {
      // 节点的构造函数
      const Node = function (val) {
        this.val = val; // 节点的值
        this.left = null; // 左子树节点
        this.right = null; // 右子树节点
      }
      // 根节点
      this.root = null;
      // 插入root的子节点
      const insertNode = (parentNode, childNode) => {
        // 左子树构造
        if (childNode.val < parentNode.val) {
          // 为空时赋值，否则继续延伸
          if (parentNode.left === null) {
            parentNode.left = childNode;
          } else {
            insertNode(parentNode.left, childNode);
          }
        } else { // 右子树的构造 childNode.val > parentNode.val
          if (parentNode.right === null) {
            parentNode.right = childNode;
          } else {
            insertNode(parentNode.right, childNode);
          }
        }
      }
      // 插入节点的实例方法
      this.insert = (val) => {
        let thisNode = new Node(val);
        // 根节点赋值
        if (this.root === null) {
          this.root = thisNode;
        } else {
          // 插入子节点
          insertNode(this.root, thisNode);
        }
      }
    }

    // 节点数组
    var nodes = [4, 2, 7, 1, 3];
    var binaryTree = new BinaryTree();
    nodes.forEach(val => {
      binaryTree.insert(val);
    });
    var result = binaryTree.root;
    console.log(result)
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     * @param {number} val
     * @return {TreeNode}
     */
    const insertIntoBST = function (root, val) {
      const insertNode = (parentNode, childNode) => {
        // 左子树构造
        if (childNode.val < parentNode.val) {
          // 为空时赋值，否则继续延伸
          if (parentNode.left === null) {
            parentNode.left = childNode;
          } else {
            insertNode(parentNode.left, childNode);
          }
        } else { // 右子树的构造 childNode.val > parentNode.val
          if (parentNode.right === null) {
            parentNode.right = childNode;
          } else {
            insertNode(parentNode.right, childNode);
          }
        }
      }
      // 节点的构造函数
      const Node = function (val) {
        this.val = val; // 节点的值
        this.left = null; // 左子树节点
        this.right = null; // 右子树节点
      }
      let thisNode = new Node(val);
      insertNode(root, thisNode);
      return root;
    };
    console.log(insertIntoBST(result, 5))
    console.timeEnd();
  </script>
</body>

</html>