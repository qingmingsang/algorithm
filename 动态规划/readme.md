
# 概念
用一句话解释动态规划就是 **“记住你之前做过的事”**，如果更准确些，其实是 **“记住你之前得到的答案”**。

举个大家工作中经常遇到的例子。

在软件开发中，大家经常会遇到一些系统配置的问题，配置不对，系统就会报错，这个时候一般都会去 Google 或者是查阅相关的文档，花了一定的时间将配置修改好。

过了一段时间，去到另一个系统，遇到类似的问题，这个时候已经记不清之前修改过的配置文件长什么样，这个时候有两种方案，一种方案还是去 Google 或者查阅文档，另一种方案是借鉴之前修改过的配置，第一种做法其实是万金油，因为你遇到的任何问题其实都可以去 Google，去查阅相关文件找答案，但是这会花费一定的时间，相比之下，第二种方案肯定会更加地节约时间，但是这个方案是有条件的，条件如下：

* 之前的问题和当前的问题有着关联性，换句话说，之前问题得到的答案可以帮助解决当前问题
* 需要记录之前问题的答案

当然在这个例子中，可以看到的是，上面这两个条件均满足，大可去到之前配置过的文件中，将配置拷贝过来，然后做些细微的调整即可解决当前问题，节约了大量的时间。

从这些描述中发现，对于一个动态规划问题，我们只需要从两个方面考虑，那就是 **找出问题之间的联系**，以及 **记录答案**，这里的难点其实是找出问题之间的联系，记录答案只是顺带的事情，利用一些简单的数据结构就可以做到。


# 思考动态规划问题的四个步骤
一般解决动态规划问题，分为四个步骤，分别是
* 问题拆解，找到问题之间的具体联系
* 状态定义
* 递推方程推导
* 实现

这里面的重点其实是前两个，如果前两个步骤顺利完成，后面的递推方程推导和代码实现会变得非常简单。

## 问题拆解，找到问题之间的具体联系
这里拿 Quora 上面一个的例子(how should i explain dynamic programming to a 4-year-old)来讲解，`“1+1+1+1+1+1+1+1”` 得出答案是 `8`，那么如何快速计算 `“1+ 1+1+1+1+1+1+1+1”`?

我们首先可以对这个大的问题进行拆解，这里说的大问题是 `9 个 1 相加`，这个问题可以拆解成 `1 + “8 个 1 相加的答案”`，`8 个 1` 相加继续拆，可以拆解成 `1 + “7 个 1 相加的答案”`，… `1 + “0 个 1 相加的答案”`，到这里，**第一个步骤** 已经完成。

## 状态定义
**状态定义** 其实是需要思考在解决一个问题的时候我们做了什么事情，然后得出了什么样的答案，对于这个问题，当前问题的答案就是当前的状态，基于上面的问题拆解，你可以发现两个相邻的问题的联系其实是 `后一个问题的答案 = 前一个问题的答案 + 1`，这里，状态的每次变化就是 `+1`。

## 递推方程推导
定义好了状态，递推方程就变得非常简单，就是 `dp[i] = dp[i - 1] + 1`，这里的 `dp[i]` 记录的是当前问题的答案，也就是当前的状态，`dp[i - 1]` 记录的是之前相邻的问题的答案，也就是之前的状态，它们之间通过 `+1` 来实现状态的变更。

## 实现
最后一步就是实现了，有了状态表示和递推方程，实现这一步上需要重点考虑的其实是初始化，就是用什么样的数据结构，根据问题的要求需要做那些初始值的设定。
```c++
public int dpExample(int n) {
    int[] dp = new int[n + 1];  // 多开一位用来存放 0 个 1 相加的结果

    dp[0] = 0;      // 0 个 1 相加等于 0

    for (int i = 1; i <= n; ++i) {
        dp[i] = dp[i - 1] + 1;
    }

    return dp[n];
}
```

```js
function dpExample(n) {
    let dp = [];  // 多开一位用来存放 0 个 1 相加的结果
    dp[0] = 0;      // 0 个 1 相加等于 0

    for (let i = 1; i <= n; ++i) {
        dp[i] = dp[i - 1] + 1;
    }
    return dp[n];
}
console.log(dpExample(8))//8
```
可以看到，动态规划这四个步骤其实是相互递进的，
状态的定义离不开问题的拆解，
递推方程的推导离不开状态的定义，
最后的实现代码的核心其实就是递推方程，
这中间如果有一个步骤卡壳了则会导致问题无法解决，当问题的复杂程度增加的时候，这里面的思维复杂程度会上升。

# 实例
## 爬楼梯(70. Climbing Stairs)
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：
输入：2
输出：2
解释： 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
3. 
示例 2：
输入：3
输出：3
解释： 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

### 解析
爬楼梯，可以爬一步也可以爬两步，问有多少种不同的方式到达终点，我们按照上面提到的四个步骤进行分析：

问题拆解：

我们到达第 n 个楼梯可以从第 n - 1 个楼梯和第 n - 2 个楼梯到达，因此第 n 个问题可以拆解成第 n - 1 个问题和第 n - 2 个问题，第 n - 1 个问题和第 n - 2 个问题又可以继续往下拆，直到第 0 个问题，也就是第 0 个楼梯 (起点)

状态定义

“问题拆解” 中已经提到了，第 n 个楼梯会和第 n - 1 和第 n - 2 个楼梯有关联，那么具体的联系是什么呢？你可以这样思考，第 n - 1 个问题里面的答案其实是从起点到达第 n - 1 个楼梯的路径总数，n - 2 同理，从第 n - 1 个楼梯可以到达第 n 个楼梯，从第 n - 2 也可以，并且路径没有重复，因此我们可以把第 i 个状态定义为 “从起点到达第 i 个楼梯的路径总数”，状态之间的联系其实是相加的关系。

递推方程

“状态定义” 中我们已经定义好了状态，也知道第 i 个状态可以由第 i - 1 个状态和第 i - 2 个状态通过相加得到，因此递推方程就出来了 `dp[i] = dp[i - 1] + dp[i - 2]`

实现

其实可以从递推方程看到，我们需要有一个初始值来方便我们计算，起始位置不需要移动 `dp[0] = 0`，第 1 层楼梯只能从起始位置到达，因此 `dp[1] = 1`，第 2 层楼梯可以从起始位置和第 1 层楼梯到达，因此 `dp[2] = 2`，有了这些初始值，后面就可以通过这几个初始值进行递推得到。

```c++
public int climbStairs(int n) {
    if (n == 1) {
        return 1;
    }

    int[] dp = new int[n + 1];  // 多开一位，考虑起始位置

    dp[0] = 0; dp[1] = 1; dp[2] = 2;
    for (int i = 3; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
```

```js
      function climbStairs(n) {
        if (n == 1) {
          return 1;
        }
        let dp = [];
        dp[0] = 0; dp[1] = 1; dp[2] = 2;
        for (let i = 3; i <= n; ++i) {
          dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
      }
```

## 三角形最小路径和(120. Triangle)
给定一个三角形，找出自顶向下的最小路径和。
每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：
```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```
自顶向下的最小路径和为 `11（即，2 + 3 + 5 + 1 = 11）`。

说明：
如果你可以只使用` O(n) `的额外空间`（n 为三角形的总行数）`来解决这个问题，那么你的算法会很加分。

### 解析
给定一个三角形数组，需要求出从上到下的最小路径和，也和之前一样，按照四个步骤来分析：

问题拆解：

这里的总问题是求出最小的路径和，路径是这里的分析重点，路径是由一个个元素组成的，和之前爬楼梯那道题目类似，`[i][j]` 位置的元素，经过这个元素的路径肯定也会经过 `[i - 1][j]` 或者 `[i - 1][j - 1]`，因此经过一个元素的路径和可以通过这个元素上面的一个或者两个元素的路径和得到。

状态定义

状态的定义一般会和问题需要求解的答案联系在一起，这里其实有两种方式，一种是考虑路径从上到下，另外一种是考虑路径从下到上，因为元素的值是不变的，所以路径的方向不同也不会影响最后求得的路径和，如果是从上到下，你会发现，在考虑下面元素的时候，起始元素的路径只会从`[i - 1][j]` 获得，每行当中的最后一个元素的路径只会从 `[i - 1][j - 1]` 获得，中间二者都可，这样不太好实现，因此这里考虑从下到上的方式，状态的定义就变成了 “最后一行元素到当前元素的最小路径和”，对于 `[0][0]` 这个元素来说，最后状态表示的就是我们的最终答案。

递推方程

“状态定义” 中我们已经定义好了状态，递推方程就出来了
```
dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j]
```

实现

这里初始化时，我们需要将最后一行的元素填入状态数组中，然后就是按照前面分析的策略，从下到上计算即可

```c++
public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();

    int[][] dp = new int[n][n];

    List<Integer> lastRow = triangle.get(n - 1);

    for (int i = 0; i < n; ++i) {
        dp[n - 1][i] = lastRow.get(i);
    }

    for (int i = n - 2; i >= 0; --i) {
        List<Integer> row = triangle.get(i);
        for (int j = 0; j < i + 1; ++j) {
            dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + row.get(j);
        }
    }

    return dp[0][0];
}
```

```js
function minimumTotal(triangle) {
        let n = triangle.length;
        let dp = Array(n).fill([]);
        let lastRow = triangle[n - 1];

        dp[n - 1] = [...lastRow];//最后一行
        for (let i = n - 2; i > -1; --i) {//倒数第二行开始
          let row = triangle[i];//当前行
          for (let j = 0; j < i + 1; ++j) {//遍历当前行数据
            //从当前行的下一行取相邻数据取较小值,与当前值相加存入dp中
            dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + row[j];
          }
        }

        return dp[0][0];
      }
```

```js
      var minimumTotal = function (triangle) {
        for (let i = triangle.length - 2; i >= 0; i--) {
          for (let j = 0; j < triangle[i].length; j++) {
            triangle[i][j] += Math.min(triangle[i + 1][j], triangle[i + 1][j + 1])
          }
        }
        return triangle[0][0]
      }
```

```
Starting Triangle

  1
 2 3    <-- Algorithm starts here, at the second to last row
4 5 6

Step 1

  1
 6 8    <-- 2 + min(4, 5) and 3 + min(5, 6)
4 5 6

Step 2

  7    <-- 1 + min(6, 8)
 6 8
4 5 6

Step 3
Finally, 
return triangle[0][0] 
```

## 最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:
```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

进阶:
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

### 解析
求最大子数组和，非常经典的一道题目，这道题目有很多种不同的做法，而且很多算法思想都可以在这道题目上面体现出来，比如动态规划、贪心、分治，还有一些技巧性的东西，比如前缀和数组，这里还是使用动态规划的思想来解题，套路还是之前的四步骤：

问题拆解：

问题的核心是子数组，子数组可以看作是一段区间，因此可以由起始点和终止点确定一个子数组，两个点中，我们先确定一个点，然后去找另一个点，比如说，如果我们确定一个子数组的截止元素在 i 这个位置，这个时候我们需要思考的问题是 “以 i 结尾的所有子数组中，和最大的是多少？”，然后我们去试着拆解，这里其实只有两种情况：
   * i 这个位置的元素自成一个子数组;
   * i 位置的元素的值 + 以 `i - 1` 结尾的所有子数组中的子数组和最大的值

你可以看到，我们把第 `i` 个问题拆成了第 `i - 1` 个问题，之间的联系也变得清晰

状态定义

通过上面的分析，其实状态已经有了，`dp[i]` 就是 **“以 i 结尾的所有子数组的最大值”**
```
dp[i] = Math.max(dp[i - 1] + array[i], array[i])
```
化简一下就成了：
```
dp[i] = Math.max(dp[i - 1], 0) + array[i]
```

实现

题目要求子数组不能为空，因此一开始需要初始化，也就是 `dp[0] = array[0]`，保证最后答案的可靠性，另外我们需要用一个变量记录最后的答案，因为子数组有可能以数组中任意一个元素结尾

```c++
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    int n = nums.length;

    int[] dp = new int[n];

    dp[0] = nums[0];

    int result = dp[0];

    for (int i = 1; i < n; ++i) {
        dp[i] = Math.max(dp[i - 1], 0) + nums[i];
        result = Math.max(result, dp[i]);
    }

    return result;
}
```

```js
function maxSubArray(nums) {
        if (nums == null || nums.length == 0) {
          return 0;
        }

        let n = nums.length;
        let dp = [];

        dp[0] = nums[0];
        let result = dp[0];

        for (let i = 1; i < n; ++i) {
          dp[i] = Math.max(dp[i - 1], 0) + nums[i];
          result = Math.max(result, dp[i]);
        }

        return result;
      }
```

```js
function maxSubArray(A) {
    var prev = 0;
    var max = Number.MIN_SAFE_INTEGER;

    for (var i = 0; i < A.length; i++) {
        prev = Math.max(prev + A[i], A[i]);
        max = Math.max(max, prev);
    }
    return max;
}
```

# 矩阵类动态规划
矩阵类动态规划，也可以叫做坐标类动态规划，一般这类问题都会给你一个矩阵，矩阵里面有着一些信息，然后你需要根据这些信息求解问题。

其实 **矩阵可以看作是图的一种，你可以把整个矩阵当成一个图，矩阵里面的每个位置上的元素当成是图上的节点，然后每个节点的邻居就是其相邻的上下左右的位置**，我们遍历矩阵其实就是遍历图，在遍历的过程中会有一些临时的状态，也就是子问题的答案，我们记录这些答案，从而推得我们最后想要的答案。

一般来说，在思考这类动态规划问题的时候，只需要思考当前位置的状态，然后试着去看当前位置和它邻居的递进关系，从而得出我们想要的递推方程，

# 实例
## 不同路径(62. Unique Paths)
一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

例如，上图是一个7 x 3 的网格。有多少可能的路径？

说明： m 和 n 的值均不超过 100。

示例 1:
```
输入: m = 3, n = 2
输出: 3
```
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
```
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

示例 2:
```
输入: m = 7, n = 3
输出: 28
```

### 解析
给定一个矩阵，问有多少种不同的方式从起点`(0,0)` 到终点 `(m-1,n-1)`，并且每次移动只能向右或者向下，我们还是按之前提到的分析动态规划那四个步骤来思考一下：

问题拆解

题目中说了，每次移动只能是向右或者是向下，矩阵类动态规划需要关注当前位置和其相邻位置的关系，对于某一个位置来说，经过它的路径只能从它上面过来，或者从它左边过来，因此，如果需要求到达当前位置的不同路径，我们需要知道到达其上方位置的不同路径，以及到达其左方位置的不同路径

状态定义

矩阵类动态规划的状态定义相对来说比较简单，只需要看当前位置即可，问题拆解中，我们分析了当前位置和其邻居的关系，提到每个位置其实都可以算做是终点，状态表示就是 **“从起点到达该位置的不同路径数目”**

递推方程

有了状态，也知道了问题之间的联系，其实递推方程也出来了，就是
```
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
```

实现

有了这些，这道题还没完，我们还要考虑状态数组的初始化问题，对于上边界和左边界的点，因为它们只能从一个方向过来，需要单独考虑，比如上边界的点只能从左边这一个方向过来，左边界的点只能从上边这一个方向过来，它们的不同路径个数其实就只有 `1`，提前处理就好。

```c++
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];

    for (int i = 0; i < m; ++i) {
        dp[i][0] = 1;
    }

    for (int j = 0; j < n; ++j) {
        dp[0][j] = 1;
    }

    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    return dp[m - 1][n - 1];
}
```

```js
function uniquePaths(m, n) {
    let dp = Array(m).fill([]);

    for (let i = 0; i < m; ++i) {
        dp[i][0] = 1;
    }

    for (let j = 0; j < n; ++j) {
        dp[0][j] = 1;
    }

    for (let i = 1; i < m; ++i) {
        for (let j = 1; j < n; ++j) {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

```js
let store = new Map();
function uniquePaths(m, n) {
    for (let i = 1; i <= m; ++i) {
        let k = `${i},1`;
        if (!store.has(k)) {
        store.set(k, 1);
        }
    }
    for (let j = 1; j <= n; ++j) {
        let k = `1,${j}`;
        if (!store.has(k)) {
        store.set(k, 1);
        }
    }
    for (let i = 2; i <= m; ++i) {
        for (let j = 2; j <= n; ++j) {
        let k = `${i},${j}`;
        if (!store.has(k)) {
            store.set(k, store.get(`${i - 1},${j}`) + store.get(`${i},${j - 1}`));
        }
        }
    }
    return store.get(`${m},${n}`);
}
```

## 不同路径II(63. Unique Paths II)
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

说明：m 和 n 的值均不超过 100。

示例 1:

输入:
```
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
```
输出: 2

解释:
```
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

### 解析
在上面那道题的基础上，矩阵中增加了障碍物，这里只需要针对障碍物进行判断即可，如果当前位置是障碍物的话，状态数组中当前位置记录的答案就是 0，也就是没有任何一条路径可以到达当前位置，除了这一点外，其余的分析方法和解题思路和之前 一样 。

```c++
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    if (obstacleGrid.length == 0 || obstacleGrid[0].length == 0) {
        return 0;
    }

    if (obstacleGrid[0][0] == 1) {
        return 0;
    }

    int m = obstacleGrid.length, n = obstacleGrid[0].length;
    int[][] dp = new int[m][n];

    dp[0][0] = 1;

    for (int i = 1; i < m; ++i) {
        dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i - 1][0];
    }

    for (int i = 1; i < n; ++i) {
        dp[0][i] = obstacleGrid[0][i] == 1 ? 0 : dp[0][i - 1];
    }

    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];
        }
    }

    return dp[m - 1][n - 1];
}
```

```js
function uniquePathsWithObstacles1(obstacleGrid) {
    let store = new Map();
    let m = obstacleGrid.length - 1;
    let n = obstacleGrid[0].length - 1;
    let tag = false;
    for (let i = 0; i <= m; ++i) {
        let k = `${i},0`;
        if (tag) {
        store.set(k, 0);
        continue;
        }
        if (obstacleGrid[i][0] === 1) {
        store.set(k, 0);
        tag = true;
        } else {
        store.set(k, 1);
        }
    }
    tag = false;
    for (let j = 0; j <= n; ++j) {
        let k = `0,${j}`;
        if (tag) {
        store.set(k, 0);
        continue;
        }
        if (obstacleGrid[0][j] === 1) {
        store.set(k, 0);
        tag = true;
        } else {
        store.set(k, 1);
        }
    }
    for (let i = 1; i <= m; ++i) {
        for (let j = 1; j <= n; ++j) {
        let k = `${i},${j}`;
        if (obstacleGrid[i][j] === 1) {
            store.set(k, 0)
        } else {
            let l = store.get(`${i - 1},${j}`);
            let r = store.get(`${i},${j - 1}`)
            store.set(k, l + r)
        }
        }
    }
    return store.get(`${m},${n}`);
}
```

## 最小路径和(64. Minimum Path Sum)
给定一个包含非负整数的 `m x n` 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
```
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
```
输出: 7
解释: 因为路径 `1→3→1→1→1` 的总和最小。

### 解析
给定一个矩阵，问从起点`(0,0)` 到终点 `(m-1,n-1)` 的最小路径和是多少，并且每次移动只能向右或者向下，按之四个步骤来思考一下：

问题拆解

拆解问题的方式方法和前两道题目非常类似，这里不同的地方只是记录的答案不同，也就是状态不同，我们还是可以仅仅考虑当前位置，然后可以看到只有上面的位置和左边的位置可以到达当前位置，因此当前问题就可以拆解成两个子问题

状态定义

因为是要求路径和，因此状态需要记录的是 “从起始点到当前位置的最小路径和”

递推方程

有了状态，以及问题之间的联系，我们知道了，当前的最短路径和可以由其上方和其左方的最短路径和对比得出，递推方程也可以很快写出来：
```
dp[i][j] = Math.min(dp[i - 1][j] + dp[i][j - 1]) + grid[i][j]
```

实现

实现上面需要重点考虑的还是状态数组的初始化，这一步还是和前面两题类似，这里就不过多赘述

```c++
public int minPathSum(int[][] grid) {
    int m = grid.length, n = grid[0].length;

    int[][] dp = new int[m][n];

    dp[0][0] = grid[0][0];

    for (int i = 1; i < m; ++i) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }

    for (int i = 1; i < n; ++i) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
    }

    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }

    return dp[m - 1][n - 1];
}
```

```js
var minPathSum1 = function (grid) {
    let m = grid.length - 1;
    let n = grid[0].length - 1;
    let store = new Map([['0,0', grid[0][0]]]);

    for (let i = 1; i <= m; ++i) {
        let k = `${i},0`;
        let prev = `${i - 1},0`;
        store.set(k, grid[i][0] + store.get(prev));
    }
    for (let j = 1; j <= n; ++j) {
        let k = `0,${j}`;
        let prev = `0,${j - 1}`;
        store.set(k, grid[0][j] + store.get(prev));
    }
    for (let i = 1; i <= m; ++i) {
        for (let j = 1; j <= n; ++j) {
            let k = `${i},${j}`;
            let l = store.get(`${i - 1},${j}`);
            let t = store.get(`${i},${j - 1}`);
            let p = grid[i][j];
            store.set(k, p + Math.min(l, t))
        }
    }
    return store.get(`${m},${n}`);
};
```

## 最大正方形(221. Maximal Square)
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

示例:
```
输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```

### 解析
题目给定一个字符矩阵，字符矩阵中只有两种字符，分别是 `‘0’` 和 `‘1’`，题目要在矩阵中找全为 `‘1’` 的，面积最大的正方形。

刚拿道这道题，如果不说任何解法的话，其实并不是特别好想，我们先来看看切题的思路是怎么样的。

首先一个正方形是由四个顶点构成的，如果说我们在矩阵中随机找四个点，然后判断该四个点组成的是不是正方形，如果是正方形，然后看组成正方形的每个位置的元素是不是都是 `‘1’`，这种方式也是可行的，但是比较暴力，这么弄下来，时间复杂度是 `O((m*n)^4)`。

那我们就会思考，组成一个正方形是不是必须要四个点都找到？如果我们找出其中的三个点，甚至说两个点，能不能确定这个正方形呢？

你会发现，这里我们只需要考虑 正方形对角线的两个点 即可，这两个点确定了，另外的两个点也就确定了，因此我们可以把时间复杂度降为 `O((m*n)^2)`。

但是这里还是会有一些重复计算在里面，我们和之前一样，本质还是在做暴力枚举，只是说枚举的个数变少了，我们能不能记录我们之前得到过的答案，通过牺牲空间换取时间呢，这里正是动态规划所要做的事情！

问题拆解

我们可以思考，如果我们从左到右，然后从上到下遍历矩阵，假设我们遍历到的当前位置是正方形的右下方的点，那其实我们可以看之前我们遍历过的点有没有可能和当前点组成符合条件的正方形，除了这个点以外，无非是要找另外三个点，这三个点分别在当前点的上方，左方，以及左上方，也就是从这个点往这三个方向去做延伸，具体延伸的距离是和其相邻的三个点中的状态有关

状态定义

因为我们考虑的是正方形的右下方的顶点，因此状态可以定义成 “当前点为正方形的右下方的顶点时，正方形的最大面积”

递推方程

有了状态，我们再来看看递推方程如何写，前面说到我们可以从当前点向三个方向延伸，我们看相邻的位置的状态，这里我们需要取三个方向的状态的最小值才能确保我们延伸的是全为 `‘1’` 的正方形，也就是
```
dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
```

实现

在实现上，我们需要单独考虑两种情况，就是当前位置是 `‘1’`，还有就是当前位置是 `‘0’`，如果是 `‘0’` 的话，状态就是 0，表示不能组成正方形，如果是 `‘1’` 的话，我们也需要考虑位置，如果是第一行的元素，以及第一列的元素，表明该位置无法同时向三个方向延伸，状态直接给为 `1` 即可，其他情况就按我们上面得出的递推方程来计算当前状态。

```c++
public int maximalSquare(char[][] matrix) {
    if (matrix.length == 0 || matrix[0].length == 0) {
        return 0;
    }

    int m = matrix.length, n = matrix[0].length;

    int[][] dp = new int[m][n];

    int maxLength = 0;

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (matrix[i][j] == '1') {
                if (i == 0 || j == 0) {
                    dp[i][j] = matrix[i][j] == '1' ? 1 : 0;
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j], 
                                        Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
                }

                maxLength = Math.max(dp[i][j], maxLength);
            }
        }
    }

    return maxLength * maxLength;
}
```

```js
var maximalSquare = function (matrix) {
    if (matrix.length == 0) {
        return 0;
    }
    let m = matrix.length - 1;
    let n = matrix[0].length - 1;
    let max = 0;
    for (let i = 0; i <= m; i++) {
        for (let j = 0; j <= n; j++) {
            let v = matrix[i][j];
            if (v == 1) {
                let l = Number((matrix[i - 1] || [])[j]) || 0;
                let t = Number((matrix[i] || [])[j - 1]) || 0;
                let lt = Number((matrix[i - 1] || [])[j - 1]) || 0;
                let x = Math.min(l, t, lt) + 1;
                max = Math.max(max, x);
                matrix[i][j] = x;
            }
        }
    }
    return max * max;
};
```
