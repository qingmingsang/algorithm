假设给定一个数组A和一个整数x,你必须找出x是否存在于数组中A.

解决此问题的简单方法是遍历整个数组A并检查任何元素是否等于x.
```
for i : 1 to length of A
    if A[i] is equal to x
        return TRUE
return FALSE
```
计算机中的每个操作大约需要固定的时间。假设每个操作消耗时间c。执行的代码行数实际上取决于x。在算法分析期间，大多数情况下，我们会考虑最坏的情况，即x不在数组A中 。在最坏的情况下，if条件将运行N次, N是数组A的长度 。因此，在最坏的情况下，总执行时间为`(N*c+c)`. `N*c`对应if语句,c对应return语句（忽略某些操作，如i赋值 ).

显而易见,总时间取决于数组的长度 。如果数组的长度会增加，执行时间也会增加。

增长顺序(Order of growth )是执行时间取决于输入的长度的意思。
在上面的示例中，我们可以清楚地看到执行时间线性依赖于数组的长度。增长顺序将帮助我们轻松计算运行时间。我们将忽略低阶项(lower order terms)，因为对于大的输入而言，低阶项相对来说是微不足道的。我们使用不同的符号来描述函数的限制行为。

@1

@2

时间复杂度符号
在分析算法时，我们主要考虑O符号，因为它会给我们执行时间的上限，即最坏情况下的执行时间。
计算O注意，我们将忽略低阶项，因为对于大输入而言，低阶项相对无关紧要。
@3

```
int count = 0;
for (int i = 0; i < N; i++) 
    for (int j = 0; j < i; j++) 
        count++;
```
i=0，它将运行0次。
i=1，它将运行1次。
i=2，它将运行2次...

count++将运行的总次数为@4。因此，时间复杂度为@5.

```
int count = 0;
for (int i = N; i > 0; i /= 2) 
    for (int j = 0; j < i; j++) 
        count++;
```

@6

@7






