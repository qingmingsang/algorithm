<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>hello</title>
  <meta name="description" content="">
  <meta name="keywords" content="">
  <!-- <link rel="shortcut icon" href="favicon.ico"> -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- 默认使用webkit内核 -->
  <meta name="renderer" content="webkit">
  <!-- 兼容模式 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <link href="" rel="stylesheet">
</head>

<body>1 1108. Defanging an IP Address Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged
  IP address replaces every period "." with "[.]". Example 1: Input: address = "1.1.1.1" Output: "1[.]1[.]1[.]1" Example
  2: Input: address = "255.100.50.0" Output: "255[.]100[.]50[.]0" Constraints: The given address is a valid IPv4 address.
  <script>
    console.time();
    const sort = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const sort2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];

    const Fibonacci = (F = [], max_size = 0) => {
      /*构造一个斐波那契数组*/
      F[0] = 0;
      F[1] = 1;
      for (let i = 2; i < max_size; ++i) {
        F[i] = F[i - 1] + F[i - 2];
      }
    }

    /*定义斐波那契查找法*/
    const FibonacciSearch = (a = [], key = 0, n = 0) => {
      //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字
      let low = 0;
      let high = n - 1;

      //构造一个斐波那契数组F 
      let F = new Array(n);
      Fibonacci(F, n);

      //计算n位于斐波那契数列的位置
      let k = 0;
      while (n > F[k] - 1) {
        ++k;
      }

      //将数组a扩展到F[k]-1的长度
      let temp = [].concat(a);
      for (let i = n; i < F[k] - 1; ++i) {
        temp[i] = a[n - 1];
      }

      while (low <= high) {
        let mid = low + F[k - 1] - 1;
        if (key < temp[mid]) {
          high = mid - 1;
          k -= 1;
        } else if (key > temp[mid]) {
          low = mid + 1;
          k -= 2;
        } else {
          if (mid < n) {
            return mid; //若相等则说明mid即为查找到的位置
          }
          return n - 1; //若mid>=n则说明是扩展的数值,返回n-1
        }
      }
      return -1;
    }

    console.warn(FibonacciSearch(sort, 0, sort.length))
    console.warn(FibonacciSearch(sort, 1, sort.length))
    console.warn(FibonacciSearch(sort, 2, sort.length))
    console.warn(FibonacciSearch(sort, 5, sort.length))
    console.warn(FibonacciSearch(sort, 6, sort.length))
    console.warn(FibonacciSearch(sort, 9, sort.length))
    console.warn(FibonacciSearch(sort, 10, sort.length))
    console.warn(FibonacciSearch(sort, 14, sort.length))
    console.warn('--------------')
    console.warn(FibonacciSearch(sort2, 0, sort2.length))
    console.warn(FibonacciSearch(sort2, 1, sort2.length))
    console.warn(FibonacciSearch(sort2, 2, sort2.length))
    console.warn(FibonacciSearch(sort2, 5, sort2.length))
    console.warn(FibonacciSearch(sort2, 6, sort2.length))
    console.warn(FibonacciSearch(sort2, 9, sort2.length))
    console.warn(FibonacciSearch(sort2, 11, sort2.length))
    console.warn(FibonacciSearch(sort, 15, sort.length))
    console.timeEnd();

    //二分法查找有序数组
    function binSearch(arr, data) {
      var upperBound = arr.length - 1;
      var lowerBound = 0;
      while (lowerBound <= upperBound) {
        var mid = Math.floor((upperBound + lowerBound) / 2);
        if (arr[mid] < data) {
          lowerBound = mid + 1;
        } else if (arr[mid] > data) {
          upperBound = mid - 1;
        } else {
          return mid;
        }
      }
      return -1;
    }
    //统计查找出的数据的个数
    function count(arr, data) {
      var count = 0;
      var position = binSearch(arr, data);
      if (position > -1) {
        ++count;
        for (var i = position - 1; i > 0; --i) {
          if (arr[i] == data) {
            ++count;
          } else {
            break;
          }
        }
        for (var i = position + 1; i < arr.length; ++i) {
          if (arr[i] == data) {
            ++count;
          } else {
            break;
          }
        }
      }
      return count;
    }
  </script>
</body>

</html>